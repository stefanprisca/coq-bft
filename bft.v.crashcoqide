Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.
Require Export Coq.Strings.String.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Coq.Lists.List.
Import ListNotations.
Require Import String.
Require Import Maps.
Open Scope string_scope.

Definition ReplicaId := string.
Definition SysView := string.

Inductive Message : Type := 
| message: ReplicaId -> string -> Message.

Notation "<< rId , pLoad >>" := (message rId pLoad).


Definition GetRID (msg : Message) : ReplicaId :=
  match msg with
  | message x y => x
  end.

Definition GetPLoad (msg : Message) : string :=
  match msg with
  | message x y => y
  end.

Definition Ledger := list (string * nat).
Definition EmptyLedger : Ledger :=  nil.

Fixpoint beq_ledgers (l1 l2 : Ledger) :=
match l1 with
| nil => match l2 with
          | nil => true
          | _ => false
         end
| (s1, n1)::t => match l2 with
          | nil => false
          | (s2, n2)::t2 => andb (andb (beq_string s1 s2) (beq_nat n1 n2)) (beq_ledgers t t2)
         end
end.

Definition SysState := total_map Ledger.
Definition MessageBox := list Message.
Definition Replica := SysState -> Message -> MessageBox -> SysState.
Definition SysReplicas := list (ReplicaId * Replica).

Inductive System : Type := 
  | system : SysView -> SysState -> SysReplicas -> System.

Definition GetView (sys : System) := 
  match sys with
  | system view _ _ => view
  end.

Definition GetState (sys : System) := 
  match sys with
  | system _ state _ => state
  end.

Definition GetReplicas (sys : System) := 
  match sys with
  | system _ _ replicas => replicas
  end.

Fixpoint findReplicaHelper (replicas : SysReplicas) (rId : ReplicaId) :=
match replicas with
| nil => None
| (rId', r)::t => if beq_string rId rId' then (Some r)
                  else findReplicaHelper t rId
end.

Definition FindReplica (sys : System) (rId:ReplicaId) :=
let replicas := GetReplicas sys in
  findReplicaHelper replicas rId.


Definition EmptyState : SysState :=  (fun _ => EmptyLedger).
Definition EmptyReplicas : SysReplicas :=  nil.

Definition ProcessMessage (sys:System) (rId : ReplicaId) (msg:Message) (msgBox : MessageBox) :=
 match (FindReplica sys rId) with
    | None => sys
    | Some replica =>
      let sysState' := (replica (GetState sys) msg msgBox) in
        (system "foo" sysState' (GetReplicas sys))
  end.

Fixpoint ProcessAllMessages (sys:System) (msgBox: MessageBox) : System := 
  match msgBox with
  | nil => sys
  | msg::t => let rId := GetRID msg in
              let sys' := ProcessMessage sys rId msg msgBox in
                ProcessAllMessages sys' t
  end
.

Definition Request := string.

Definition ProcessRequest (sys : System) (req : Request) :=
  ProcessAllMessages sys [<<"primary", req>>].


Fixpoint getCommonLedger (state : SysState) (replicas: SysReplicas) (gLedger : Ledger) :=
match replicas with
    | nil => Some gLedger
    | (rId, _)::t => if (beq_ledgers (state rId) gLedger) then (getCommonLedger state t gLedger)
                      else None
end.

Definition GetGlobalLedger (sys:System) : option Ledger :=
  let state := GetState sys in
    let gLedger := state "primary" in
      let replicas := GetReplicas sys in
         getCommonLedger state replicas gLedger.

Definition NonFaulty (rId : ReplicaId) : Prop := True.
Definition MajorityNonFaulty (sys:System) : Prop := True.

Inductive StateValid : System -> Prop :=
| empty_valid : forall sys:System, (GetState sys) = EmptyState 
                  -> StateValid sys.


Lemma system_safety: forall (sys:System),
  MajorityNonFaulty sys
  -> StateValid sys
  -> forall (r:Request), StateValid (ProcessRequest sys r).
Proof. Admitted.

(*
Theorem byzantine_fault_tolerant : forall (sys:System) (msgBox : MessageBox),
    MajorityNonFaulty sys 
    -> StateValid sys
    -> StateValid (ProcessAllMessages sys msgBox).
Proof. intros. destruct sys as [view state replicas].
induction msgBox. 
  - simpl in H0. simpl. apply H0.
  - induction replicas.
    + apply IHmsgBox.
    + apply system_safety; assumption.
Qed.*)

